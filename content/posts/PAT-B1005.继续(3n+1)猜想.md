---
title: "PAT-B1005.继续(3n+1)猜想"
date: 2021-07-12

---

# PAT-B1005.继续(3n+1)猜想

>    作者：freedom3219

>    审核：AKA二夕




## 一、题目详情

### 题目描述：

卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。

当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 *n*=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 *n*=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 *n* 为“关键数”，如果 *n* 不能被数列中的其他数字所覆盖。

现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。

### 输入格式：

每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 *K* (<100)，第 2 行给出 *K* 个互不相同的待验证的正整数 *n* (1<*n*≤100)的值，数字间用空格隔开。

### 输出格式：

每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。

### 输入样例：

```out
6
3 5 6 7 8 11
```

### 输出样例：

```out
7 6
```

---

## 二、题目分析

大家好！本期给大家带来了 **“PAT-B1005.继续(3n+1)猜想”** 。这个标题是不是有点熟悉呢？没错，它就是 PAT-B 系列的第一题的拓展。第一题很简单，而这一题的情况有些复杂，下面我们来一起仔细阅读并分析一下题目：

### 1、题目前瞻

这题一上来就提到了卡拉兹(Callatz)猜想，我们先来看看它的定义： `对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1` 。

### 2、题目思路分析

#### ①解题方法

那我们先来大概说一下解题的思路。在验证猜想的过程中，每一步都会有一个数，题目想让我们避免重复验证，只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。求出关键数，并逆序输出。

大致的解题思路应该是，先定义好输入的数，还需要定义一个数组去存储每一步计算出的数，从而从中寻找出覆盖的数和关键的数。这题我们还是用 C++ 和 Java 两种语言去解题，但是用这两种语言去解还是有一些出入的地方。

下面我们用来两种语言来实现，具体内容如下：

#### ②Java 语言写法

这题用 Java 解还是先构造一个 Scanner 对象，用来输入；在 Java 解法中，我们用到了三个数组，test 数组用来存放需要验证的数，A 数组用来存放验证数每一步计算出的数，B 数组用来存入关键数和进行排序；解题关键就看三个数组的使用，test 数组和 A 数组会用在一起，因为 A 数组就是存放 test 数组中重复计算的数；第一步我们先写出 for() 循环，在循环中输入 n ,并将 n 赋值给 test 数组，用 while() 循环计算数 n ,得到所有每一步的值都存入 A 数组并加一，代码如下：

```java
for (int i = 0; i < K; i++) {
    int n = in.nextInt();
    test[i] = n;
    while (n != 1) {
        if (n % 2 == 0) {
            n /= 2;
        } else {
            n = (3 * n + 1) / 2;
        }
        if (n <= 100) {
            A[n] ++;
        }
    }
}
```

然后再用一个 for() 循环遍历找出关键数，用 `if (A[test[i]] == 0) { B[size ++] = test[i]; }` 将关键数存入 B 数组；接着，我们需要对关键数进行排序，代码如下：

```jaa
for (int i = 0; i < size; i++){
     for (int j = 0; j < (size - 1) - i;j ++) {
         if (B[j] < B[j + 1]) {
            int temp = B[j];
            B[j] = B[j + 1];
            B[j + 1] = temp;
         }
     }
}
```

最后，我们只需要用循环遍历输出就行了。

#### ③C/C++ 语言写法

C++ 解法和 Java 相差不大，只是语法不同。这里定义了 bool 函数 : `bool cmp(int a, int b) {return a > b;}` 用来排序；数组用到了 `vector<int> v(k)` 动态数组，和一个 arr[] 数组。代码如下：

```c++
for (int i = 0; i < k; i++) {
    cin >> n;
    v[i] = n;
    while (n != 1) {
        if (n % 2 != 0) n = 3 * n + 1;
        n = n / 2;
        if (arr[n] == 1) break;
        arr[n] = 1;
    }
}
```

C++ 解法中的第一步和 Java 的这里一样，都是用数组存入每一步计算的数并赋值 1，在排序这里会比 Java 简洁许多，使用 sort() 方法 ` sort(v.begin(), v.end(), cmp);` 接着就是按照输出格式进行输出：

```c++
for (int i = 0; i < v.size(); i++) {
    if (arr[v[i]] == 0) {
        if (flag == 1) cout << " ";
        cout << v[i];
        flag = 1;
    }
}
```





---

## 三、代码实现

**Java语言实现如下：**

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int K = in.nextInt();
        int[] test = new int[K];
        int[] A = new int[101];
        int[] B = new int[101];
        for (int i = 0; i < K; i++) {
            int n = in.nextInt();
            test[i] = n;
            while (n != 1) {
                if (n % 2 == 0) {
                    n /= 2;
                } else {
                    n = (3 * n + 1) / 2;
                }
                if (n <= 100) {
                    A[n] ++;
                }
            }
        }
        int size = 0;
        for (int i = 0; i < K; i++) {
            if (A[test[i]] == 0) {
                B[size ++] = test[i];
            }
        }
        for (int i = 0; i < size; i++){
            for (int j = 0; j < (size - 1) - i;j ++) {
                if (B[j] < B[j + 1]) {
                    int temp = B[j];
                    B[j] = B[j + 1];
                    B[j + 1] = temp;
                }
            }
        }
        for (int i = 0; i < size; i++) {
            System.out.print(B[i]);
            if (i != size - 1) {
                System.out.print(" ");
            }
        }
    }
}
```

**C++语言实现如下：**

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int arr[10000];
bool cmp(int a, int b) {return a > b;}
int main() {
    int k, n, flag = 0;
    cin >> k;
    vector<int> v(k);
    for (int i = 0; i < k; i++) {
        cin >> n;
        v[i] = n;
        while (n != 1) {
            if (n % 2 != 0) n = 3 * n + 1;
            n = n / 2;
            if (arr[n] == 1) break;
            arr[n] = 1;
        }
    }
    sort(v.begin(), v.end(), cmp);
    for (int i = 0; i < v.size(); i++) {
        if (arr[v[i]] == 0) {
            if (flag == 1) cout << " ";
            cout << v[i];
            flag = 1;
        }
    }
    return 0;
}
```


---

## 四、结束语

注意事项：根据题目，第 1 行给出一个正整数 *K* (<100)，第 2 行给出 *K* 个互不相同的待验证的正整数 *n* (1<*n*≤100) 的值，所以注意给出的数不超 100； 

本期 **PAT-B1005.继续(3n+1)猜想** 就讲到这里。OK，这一期就到这里，让我们期待下一期的内容吧！



