<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OS-EDU</title><link>https://os-edu.github.io/</link><description>Recent content on OS-EDU</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 18 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://os-edu.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>PAT_B1016.部分 A + B</title><link>https://os-edu.github.io/pat-b1016/</link><pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate><guid>https://os-edu.github.io/pat-b1016/</guid><description>PAT_B1016.部分 A + B 作者：freedom3219
审核：AKA二夕
一、题目详情 题目描述： 正整数A的 “D~A~ （为1位整数）部分” 定义为由A中所有D~A~ 组成的新整数P~A~ 。例如：给定A = 3862767， D~A~ = 6，则A的“6的部分”P~A~ 是66，因为A中有2个6。
输入格式： 在一行中依次输入A、D~A~ 、B、D~B~ ，中间以空格分隔，其中 A &amp;gt; 0, B &amp;lt; 10^10^。
输出格式： 在一行中输出P~A~ + P~B~ 的值。
输入样例1： 3862767 6 13530293 3 输出样例1： 399
输入样例2： 3862767 1 13530293 8 输出样例2： 0
二、题目分析 当我们看到这一题的时候，第一印象应该是：“这一题的题目好短，应该很简单”。哈哈，没错，这一题正如你想的一样，的确是很简单的。下面我们来仔细阅读本题，抽取题目的有效信息如下：
正整数A的 “D~A~ （为1位整数）部分” 定义为由A中所有D~A~ 组成的新整数P~A~ 。例如：给定A = 3862767， D~A~ = 6，则A的“6的部分”P~A~ 是66，因为A中有2个6。</description></item><item><title>参与贡献指南</title><link>https://os-edu.github.io/add_contributing_guide/</link><pubDate>Sat, 09 Jan 2021 00:00:00 +0000</pubDate><guid>https://os-edu.github.io/add_contributing_guide/</guid><description>贡献指南 作者：Plato-W
审核：AKA二夕
前段时间一直有小伙伴在询问具体该如何参与项目中来，所以在借鉴了一些开源项目指南的基础上，编写了本文，如果感觉有不足之处，欢迎大家来适当补充。
这篇贡献指南会指导你如何为 KO——CSP 贡献一份自己的力量，请在要提 Issue 或者 Pull request 之前花几分钟来阅读一遍这篇指南。
提交 Issue 提交 Pull Request 提交 issue 有任何疑问，欢迎提交 Issue。提交 issue 之前:
避免提交重复的 issue，在提交之前搜索现有的 issue。 确定 issue 的类型，并在标题或内容中标明。如 add questions, bug, documentation, discussion, help wanted等。查看所有标签。 提交 Pull Request 如果你准备提交 Pull Request ，可参考以下流程：
1. 认领 issue 所有的题目都会建立一个对应的issue，可以选择在 Issue 列表 中挑选任务，然后在该 issue 下回复一下自己简单的解题思路，表明你将认领该 issue，如果发现issue已被认领或者closed，但是还有不同的解法，可以自己new issue，issue的标题要表明对应的题目编号。
可以在 Issue 流程相关中找到更多与 Issue 流程相关的信息。
2. 克隆仓库 访问 KO&amp;ndash;CSP 仓库的主页，并 Fork 到自己的账号下。</description></item><item><title>PAT_B1012.数字分类</title><link>https://os-edu.github.io/pat_b1012/</link><pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate><guid>https://os-edu.github.io/pat_b1012/</guid><description>PAT_B1012.数字分类 作者：AKA二夕
一、题目详情 题目描述： 给定一系列正整数，请按照要求对数字进行分类，并输出以下五类数字：
A1 = 能被5整除的数字中所有偶数的和；
A2 = 将被5除后余1的数字按给出的顺序进行交错求和，即计算出n1 - n2 + n3 -n4 ……；
A3 = 被5除后余2的数字的个数；
A4 = 被5除后余3的数字的平均数，精确到小数点后一位；
A5 = 被5除后余4的数字中最大数字。
输入格式： 每个输入包含一个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。
输出格式： 对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但末行不得有多余的空格。 若其中某一类数字不存在，则在相应位置输出&amp;quot;N&amp;rdquo;。
输入样例1： 13 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例1： 30 11 2 9.7 9 输入样例2： 8 1 2 4 5 6 7 9 16 输出样例2： N 11 2 N 9 二、题目分析 定义基本变量如下：</description></item><item><title>PAT-B1008.数组元素循环右移问题</title><link>https://os-edu.github.io/pat_b1008/</link><pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate><guid>https://os-edu.github.io/pat_b1008/</guid><description>B1008.数组元素循环右移问题 作者：AKA二夕
一、题目详情 题目描述： 一个数组A中存有N（&amp;gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A0 A1 ⋯ AN−1 ）变换为（AN−M ⋯ AN−1 A0 A1⋯AN−M−1*）（最后* M*个数循环移至最前面的* *M* 个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？
输入格式: 每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。
输出格式: 在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。
输入样例: 6 2 1 2 3 4 5 6 输出样例: 5 6 1 2 3 4 二、题目分析 由题目信息可知，需要我们做的是根据所输入的数字，移动数组中的元素到指定位置。但是吧，它却增加了一堆限制条件。比如：不允许使用另外数组的情况下、又要考虑移动元素的次数最少 ， 完成该操作。这样一来是不是有点棘手呢。。。。但是我们再仔细审题，可以得出 实际上只测试循环右移之后得到的结果而不管过程。所以对于此类题目，我们其实不用管那么多限制，直接按照输出和输出的要求完成操作即可。
另外还有一点需要注意的是，题目中并没有给出 M 的最大值，因此我们有可能会误判 M &amp;lt; N ，所以需要在输入 N 和 M 后令 M = M % N; 这样一来就可以保证 M &amp;lt; N 了，使后面的操作更简便。这样方法也是我在以后解决相关问题的时候经常会使用到的 取余思想 ，其依据是：对一个长度为 N 的序列，右移 N 位之后的序列和当前序列相同。</description></item><item><title>B1046题解</title><link>https://os-edu.github.io/b1046/</link><pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate><guid>https://os-edu.github.io/b1046/</guid><description>B1046.划拳 作者：freedom3219
审核：AKA二夕
一、题目详情 题目描述： 划拳是中国酒文化中的一个有趣的组成成分。酒桌上两个人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家自罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。
下面给出甲、乙两人的划拳记录，请统计他们最后分别喝了多少杯酒。
输入格式： 第一行先给出一个正整数N(N &amp;lt;= 100)；随后N行每行给出一轮划拳的记录，格式为：甲喊 甲划 乙喊 乙划
其中“喊”是喊出的数字，“划”是划出的数字。均为不超过100的正整数（两只手一起划）。
输出格式： 在一行中先后输出甲、乙两人喝酒的杯数，其间以一个空格间隔。
输入样例： 5 8 10 9 12 5 10 5 10 3 8 5 12 12 18 1 13 4 16 12 15 输出样例： 1 2
二、题目分析 下面我们来仔细阅读本题，抽取题目的有效信息如下：
每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家自罚一杯酒。分析得出:甲划+乙划=甲喊，则甲赢；甲划+乙划=乙喊，则乙赢；甲划+乙划=甲喊=乙喊，则此局为平局；由此看出：甲赢此局，乙自罚一杯，否则相反；平局则继续。
现在再来一看，此题就很清晰了。我们可以创建变量 failA 、failB 分别记录甲乙两人输的次数，初始值均为0,。输入甲乙喊的数字 a1 、 b1 以及甲乙划的数字 a2 、b2 ， 如果 a1 + b1 == a2 且 a1 + b1 !</description></item><item><title>B1001题解</title><link>https://os-edu.github.io/b1001/</link><pubDate>Thu, 19 Nov 2020 00:00:00 +0000</pubDate><guid>https://os-edu.github.io/b1001/</guid><description>B1001.害死人不偿命的(3 * n + 1)猜想 作者：AKA二夕
一、题目详情 题目描述： 卡拉兹猜想：对于任何一个自然数n，如果它是偶数，那么把它一半砍掉；如果它是奇数，那么把(3 * n + 1)砍掉一半。 这样一直反复砍下去，最后一定在某一步得到 n = 1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，据说当时耶鲁大 学师生齐动员，拼命想证明这个貌似很荒唐的命题，结果闹得学生们无心学业，一心只证(3 * n + 1)，以至于有人说这是一个 阴谋，卡拉兹是在蓄意延缓美国数学界与科研界的进展…… 此处并非要证明卡拉兹猜想，而是给定的任一不超过1000的正整数n，简单地数一下，需要多少步才能得到 n = 1？
输入格式： 每个测试输入包含1个测试用例，即给出自然数n的值。
输出格式： 输出从n计算到1需要的步数。
输入样例： 3 输出样例： 5 二、题目分析 当时正读到题目的第一感觉就是，这是个什么玩意，稀里糊涂的，卡拉兹猜想 要证明这玩意嘛？？但让我们静下心来，再慢慢仔细阅读一遍，就会发现题干的内容都是唬人的。抽取题目的有效信息如下：
对于任意的自然数n，这个n要么是偶数，要么是奇数，如果是偶数的话就变成它原来的一半`n = n / 2;` 否则的话是奇数，则`n = (3 * n + 1) / 2;` 如此反复循环，最终能得到`n = 1;` 。 看吧，这样一来是不是很清晰了，那么如何判断一个自然数n，是偶数还是奇数呢，并且对其作出相应的处理，这不明显是一个if ... else ... 嘛；至于判断它的奇偶性呢，利用我们小学一年级学过的知识，偶数是2的倍数 ，所以判断条件是n % 2 == 0。</description></item><item><title>社区发展规划</title><link>https://os-edu.github.io/%E7%A4%BE%E5%8C%BA%E5%8F%91%E5%B1%95%E8%A7%84%E5%88%92/</link><pubDate>Wed, 11 Nov 2020 00:00:00 +0000</pubDate><guid>https://os-edu.github.io/%E7%A4%BE%E5%8C%BA%E5%8F%91%E5%B1%95%E8%A7%84%E5%88%92/</guid><description>OS-Edu 起因 起初在准备ccf的csp认证考试，查阅了相关资料之后，发现并没有系统的讲解，或者说准备方法。其实说白了，也没啥需要准备的，就是刷题嘛，23333……但是既然是刷题，就应该是有方法有技巧的，不能盲目的乱刷，要不然丢了时间，效果还不太明显。
之前，有了半年的leetcode刷题经验，所以对于算法而言，也算刚入门了吧，哈哈哈哈。但是一开始对于准备csp认证而言，是毫无头绪的，不知从哪下手。在github上我们可以找到很多优秀的关于算法的项目以及相关的刷题项目，但这些项目面向的大众往往都是求职者，对于数据结构以及算法已经有了初步了解的人群，所选的题目也大多数来自于leetcode、牛客网等等，所以相对而言门槛较高。对于毫无经验的新手玩家来说，毫无疑问是一块硬骨头，似乎不怎么好下手。
所以针对出现的以上现象，我们打算创建一个适合大学生刷题的项目，由于我们的小伙伴能力有限，不足之处，还望各路大神批评指正。
项目 KO&amp;ndash;CSP 简介： 该仓库主要用于刷题记录，上传各组题目以及案例测试，也是我们创建的项目的起点吧。题目内容主要来源于胡凡老师所编写的《算法笔记》，在后续我们会根据收集到的题目慢慢补充，争取让项目越来越完善，适用于更多人群。
项目需求： 掌握C\C++、Java、Python等至少一门主流的编程语言‘ 掌握基础的数据结构相关的内容，例如：数组、链表、栈、二叉树以及图等等； 拥有一定量的刷题经验优先。 仓库地址： https://github.com/OS-EDU/KO--CSP
os-edu-site 简介： 项目的web页面，主要用于更新刷题的相关题解、与之有关的基础知识，从而使得更多人参与进来；以及项目的未来发展趋势等等。
打算基于hugo实现项目的静态网页，本着简洁高效的原则，尽可能多的兼容更多内容。
项目需求： 掌握HTML、CSS以及JavaScript等前端常用编程语言； 能够熟练使用hugo部署静态网页； 文案撰写、文章编辑； 网站开发和维护。 仓库地址： https://github.com/OS-EDU/os-edu.github.io
未来项目 待定，根据发展而定……
志愿者 志愿者招募： 为了更好的推广开源，我们诚挚的邀请您加入志愿者行列，只要您：
热情，大方，细心，有责任心 热爱开源，愿意为中国本土的开源发展贡献自已的一份力量 具有良好的团队合作意识 具备下述能力中的任何一条，或者您认为我们需要的能力： 解决网站模板的问题； 构建题库以及相关题解； 参与社区维护： 维护、编辑公众号文章 设计相关logo、推送图 发布相关平台文章 给出相关的建议。 志愿者福利： 首先，我们希望您是真的喜爱、热爱开源，愿意投身到改变世界的开源事业当中。
其次，通过参与 项目的志愿活动，您可以：
学习开源知识，拓展视野 提升刷题能力 掌握开源项目的运作方式，深入了解开源文化 联系邮箱：wangfuzheng0814@foxmail.com</description></item><item><title/><link>https://os-edu.github.io/pat_b1011/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://os-edu.github.io/pat_b1011/</guid><description>PAT-B1011 :A + B 和 C 作者：DHY2020 AKA二夕
审核：AKA二夕
一、题目描述： 给定区间[-2^31, 2^31]内的三个正整数A、B和C，请判断 A + B 是否大于 C。
输入格式： 第一行给出正整数T（T &amp;lt;= 10），即测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。
输出格式： 对每组测试用例，如果A + B &amp;gt; C，在一行中输出“Case #X: true”；否则给出“Case #X: false”，其中X是测试用例的编号（从1开始）。
输入样例： 4 1 2 3 2 3 4 2147483647 0 2147483646 0 -2147483648 -2147483647 输出样例： Case #1: false Case #2: true Case #3: true Case #4: false 二、题目分析 1、解法一分析： 首先我们审题，题目告诉我们需要三个变量去存A，B，C，并且给定了A、B、C的范围，那么我们需要确定用什么样的基本数据类型。这次的范围我们选用long就够了，通过观察输入样例，我们发现输入格式非常的整齐，有点像一个柜子上整齐的排满了抽屉，而且也很像矩阵，还很像多维数组，这样我们就用多维数组来接受输入的话就能一次性的接受所有的数据。
那么怎么来操纵多维数组呢，我想到的最简单的方法就是嵌套循环，就像一层层的打开抽屉，然后把东西装入抽屉。题目很简单就是比较A+B与C的大小，最简单的我们就把数组的第一位当作A，第二位当作B，第三位当作C，这样通过数组的下标就很简单的可以进行比较运算。所以本次需要的变量有T用于告诉计算机我们要输入多少组数据，然后再来一个二位数组Arr，一开始不指定有几行，让T来限定数组的行，列我们就规定三行就好了。输入和输出是一样的，都是利用双重for循环，遍历数组就可以了。
2、解法二分析： 看见输入格式中提到。第一行给出正整数T 这个T也就是测试用例的个数。那么我们就可以围绕着这个T琢磨一下，该如何依次输出和输出案例呢？？判断 A + B 是否大于 C，并且根据所判断的结果进行不同的输出，这明摆着就是一个 if……else 选择分支结构嘛，至于T，我们可以使用一个while循环来处理，while(T--) 这样每执行一次循环，T就减一，从而可以完成操作。</description></item></channel></rss>